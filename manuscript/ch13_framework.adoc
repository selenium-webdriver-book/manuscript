= Chapter 13: Forming a Framework

:imagesdir: ../images/ch13_framework

This chapter covers

* Problems with using `WebDriver` and `WebElement` directly
* Adding more functionality to wrapped `WebDriver` and `WebElement`
* Making framework backwards compatible with existing codebase

Part one and two of this book will have given you enough strategies to deal with most of the common automation techniques that you need for working with web applications. Especially in Chapter 12, we mentioned how to attach more responsibilities to original `WebDriver` by wrapping it inside a `DelegatingWebDriver` as an extension point so you can extend it to have a `BaseUrlDriver` to calculate url based on the base url of the project. In this chapter, we will take it even further and look at how you encapsulate other classes and interfaces and build a productivity framework on top of Selenium WebDriver.  We will cover a number of techniques to encapsulate common code into a framework, so that the your code is smaller, and more reliable.

We use framework to refer an abstraction layer between automation code written by QA engineers and Selenium WebDriver library. We believe this layer can save you tremendous effort in handling the same concern individually over and over again.

Why would you want to create a framework? Why not use WebDriver directly?

Selenium is a common purpose library used for web automation. It doesn't know how your web application will be designed. So they only provide basic handling for your need. From WebDriver perspective, everything on a web page is an element. An input field is an element, a radio button is an element and a table is an element too. But the behavior and properties of these elements differ dramatically. So we need to use combined actions to handle each element. Also, when working on a medium sized project, there are many test cases for automation engineers to implement. And there are many concerns are very similar or identical. Without a framework, each developer needs to deal with the same situation repeatedly. Even worse, different engineer may come with different solutions for the same kind of problem. It will make the automation code hard to maintain. If you've done a certain amount of coding with WebDriver you probably have come across a number of common problems:

* Code that talks directly to a `WebDriver` can be verbose, especially when dealing with explicit waits.
* Form interaction is standard and can be simplified, but it is not done inside Selenium WebDriver library.
* When automating page flow, the repeated code are noticeable and massive.
* When examine a table with many rows, no guidance on how to make the assertion so it takes unnecessary to fix the changed conditions
* You need to write complex code to deal with elements such as tables or datepickers without a framework.

We will use some example to explain the necessity of introducing a framework and all above mentioned problems will be addressed in this roadmap,

image::roadmap.png[title=Roadmap of part 3]

At the end of part 3 you will have learnt the principles for exposing a well-defined API to simplify your code, with examples of a light-weight framework written to illustrate some principles and practices.

We will use a simple automation task to illustrate the verboseness of dealing with WebDriver directly in your test code. And we will use the techniques illustrated in the following picture to solve the problem gracefully.

image::chapter-13-overview.png[title=Overview of the framework]

At the end of this chapter you will have learnt the principles of how to expose a well-defined API to simplify your code, with examples of a light-weight framework written to illustrate some principles and practices.

== Problems with using `WebDriver` and `WebElement` directly

Often, people encounter strange behaviors in automating web applications, as we learnt from Chapter 6. The reason is web technology is very complex and web pages are built upon many layers. Also, modern web pages are usually single page application built using AJAX technology. When automating pages with AJAX technology, additional cautions need to be taken to avoid some common pitfalls. We are going to revisit some of the old tests next.

=== Locating Elements without using framework code

Consider the location chooser in figure <<location-chooser>> below. When you click on the "choose location" button under the "Where is your next vacation?" header, there is a delay as the navigation fades in, if you then choose "MEXICO" the Mexican area fade in over a second or two, finally when you choose a location (such an "Cancun"), there is a further delay as the page reloads.

[[location-chooser]]
image::location-chooser.png[title=Location Chooser http://localhost:8080/location-chooser.html]

Your first attempt to write an automation code might result in some code like this,

[[error-prone]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/tests/ErrorProneLocatingLogicIT.java#L40-L51[ErrorProneLocatingLogicIT.java]
----
driver.findElement(linkText("choose location")).click();
WebElement tabMenu = driver.findElement(By.id("location"));
tabMenu.findElement(linkText("MEXICO")).click();
tabMenu.findElement(linkText("Cancun")).click();          <1>
assertEquals(0, tabMenu.findElements(linkText("Cancun")).size());
assertEquals("Cancun", driver
    .findElement(By.cssSelector(".tools-location strong"))
    .getText());
----
<1> The code will fail at this line with an `org.openqa.selenium.NoSuchElementException` but it won't print it out due to the annotation on test

This code looks very normal to most automation engineers. But when you run it, it fails due to a transition effect is used to pop up the location choices for user to choose and the code in the listing fails to wait until it fully displays the entire division. When the code is called, the link "Cancun" is still not visible. The `findElement` method in `WebElement` interface throws an `org.openqa.selenium.NoSuchElementException` when the element with the given `By` locator is not found.

[source,java]
----
.NoSuchElementException: Unable to locate element:
   {"method":"link text","selector":"Cancun"}
----

You can see the what is the problem, it is a `NoSuchElementException` footnote:[http://seleniumhq.org/exceptions/no_such_element.html] and it tells you where it is thrown,

By following the stack trace, we can find the code causes the exception and it is this line,

[source,java]
----
tabMenu.findElement(linkText("Cancun")).click();
----

After further analysis, we come to know, this is caused by the timing of the method call is not in sync with the browser. When `WebDriver` fires the `findElement` call, that particular element is indeed not displayed yet. If the `findElement` returns immediately when it doesn't find the element, it will break the automation. Even when the element appears later, the method is already returned with `NoSuchElementException`.

=== Locating Elements with explicit wait

You may recall that you have learnt from Chapter 6, there is a workaround to this problems from Selenium WebDriver library, to add implicit waiting mechanism to allow `WebDriver` to wait until the element is visible. And we didn't encourage you to use it. We also have learnt from Chapter 6 that we can use explicit waits, as shown in following listing.

[[explicit-waits1]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/tests/LocatingLogicWithExplicitWaitIT.java#L29-L41[LocatingLogicWithExplicitWaitIT.java]
----
driver.get("/location-chooser.html");
driver.findElement(linkText("choose location")).click();

WebDriverWait webDriverWait = new WebDriverWait(driver, 5);  //<1>

WebElement location = webDriverWait.until(
    new Function<WebDriver, WebElement>() {  <2>
        @Override
        public WebElement apply(WebDriver driver) {
            return driver.findElement(By.id("location"));
        }
    }
);
----
<1> `WebDriverWait` is used to add explicit wait to `WebDriver` and it can be replaced by `FluentWait<WebDriver>`
<2> Create an instance of an anonymous inner class of `Function<WebDriver, WebElement>`

When using explicit wait, `WebDriver` will not wait unless you explicitly instruct it to wait. When not specified, as soon as an element can not be found within the current search context, `WebDriver` terminates the search immediately and throws a `NoSuchElementException`. If we predict an element may appears in a late time, due to some transition effect being used to repaint the page, we need to use a `WebDriverWait` or `FluentWait` to specify the maximum wait time for searching for the element before giving up the search and throws a `TimeoutException`, as shown in the following example, we will use both `WebDriverWait` and `FluentWait` in the code, but `FluentWait` is sufficient enough, you can replace `WebDriverWait` with `FluentWait<WebDriver>`.

You need to create a separate `FluentWait<WebElement>` object if the wait is on a `WebElement` object, and each time when you want to wait on something, you need to create an instance of an anonymous inner class,

[[explicit-waits2]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/tests/LocatingLogicWithExplicitWaitIT.java#L43-L68[LocatingLogicWithExplicitWaitIT.java]
----
FluentWait<WebElement> webElementWait              //<1>
    = new FluentWait<WebElement>(location)
    .withTimeout(1000, MILLISECONDS)                //<2>
    .ignoring(NoSuchElementException.class);
WebElement canada = webElementWait.until(
    new Function<WebElement, WebElement>() {    <3>
        @Override
        public WebElement apply(WebElement element) {
            return location.findElement(By.linkText("MEXICO"));
        }
    }
);
canada.click();
WebElement allCanada = webElementWait.until(
    new Function<WebElement, WebElement>() {   <4>
        @Override
        public WebElement apply(WebElement element) {
            return location.findElement(linkText("Cancun"));
        }
    }
);
allCanada.click();
----
<1> `FluentWait<WebElement>` to add explicit wait for `WebElement`
<2> You will get a `TimeoutException` when you change the value to 10 Milliseconds
<3> Create an instance of an anonymous inner class of `Function<WebElement, WebElement>`
<4> Create another instance of an anonymous inner class of `Function<WebElement, WebElement>`

You can clearly see from the above example, the disadvantage of explicit wait is too verbose. The code increases in size after you add explicit waiting. What might help is a web driver that provides a method to encapsulate this waiting logic. That's one of the motivations of creating a framework - to provide this kind of solution behind the scene. We are going to show you some techniques used in the development of a framework.

[sidebar]
.Handling Transition Effect
****
If a page uses CSS Transition footnote:[https://www.w3.org/TR/css3-transitions/], it will likely cause some intermittent failure for `findElement` call. The only way to handle this situation is to use waiting mechanism to delay the search. We learnt in Chapter 6 that we can use explicit wait to retry the search behind the scene. Now we are going to show you is to wrap the explicit wait inside a method so it becomes easier for you to use search with wait.
We will observe another test case failure caused by transition effect in Chapter 18, when we automating Material-UI datepicker. Due to the maturity of the framework. The solution shown in Chapter 18 will be very concise.
****

== Adding more functionality to wrapped `WebDriver` and `WebElement`

In Chapter 12, we learnt that by wrapping `WebDriver` and `WebElement`, we can attach additional responsibility to these interfaces and make them easier to use. By applying the same design pattern, we can hide the code which is used to handle explicit wait and remove those cumbersome logic. We already started building the framework in Chapter 12, and right now, it becomes clearer that we need to continue evolving the framework to provide more supports for the automation developers. We can add support in wrapped `WebDriver` and `WebElement` to add one method with the build-in explicit wait, so developers can just call that method if they want the automation code to wait for an element to appear on the web page.

=== Encapsulating `FluentWait` class to provide built in waiting

We will use this technique to simplify the code in Listing <<explicit-waits1>> and Listing <<explicit-waits2>>, this technique works also for people not using Java 8, just the code will be some duplicates since *default method* is not available until Java 8, which helps in reducing some duplicates.



You have duplicated code related to waiting. In Listing <<explicit-waits1>> and Listing <<explicit-waits2>>, the following block block has been repeated 3 times with only small variant, such as `By.id("location")` in the code snippet below and `By.linkText("MEXICO")` in other place.

[source,java]
----
WebElement location = webDriverWait.until(
    new Function<WebDriver, WebElement>() {
        @Override
        public WebElement apply(WebDriver driver) {
            return driver.findElement(By.id("location"));
        }
    }
);
----

This repeated code block with only small difference in each block makes the code unpleasant to read and fragile to maintain.



Wrap both `WebElement` and `WebDriver` in new objects, and provide new methods to support waiting. Wrapping an object to simplify it is known as the *facade pattern* footnote:[http://en.wikipedia.org/wiki/Facade_pattern]. You can create an object that has the methods that you want, and delegates calls to the "delegate".

Well, how does this help us with waiting? We'd like to have a new method that allows us to find an element, but wait if it is not there. We've already got a method that supports finding elements, so you need to add another that supports waiting. You need to add the same code to two classes. How can you do this? Java 8 allows interfaces to have *default methods* footnote:[https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html]. An interface with a default method is very similar to an abstract class with a concrete methods while a class can only extend one abstract class but implements multiple interfaces.

==== What we do in Java 8

Due to the limitation with abstract class, we decided to use an interface for the purpose of adding explicit wait, but this works only in Java 8.

[[ExplicitWait-interface]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v1/ExplicitWait.java#L13-L24[ExplicitWait.java]
----
public interface ExplicitWait {   <4>

    WebElement findElement(Supplier<By> by); //<1>

    default                                //<2>
    WebElement await(Supplier<By> by) {  //<5>
        return new FluentWait<>(this)              <6>
                .withTimeout(5, SECONDS)
                .pollingEvery(10, MILLISECONDS)
                .ignoring(NoSuchElementException.class)
                .until((ExplicitWait e) -> findElement(by)); // <3>
    }
}
----
<1> Classes that implement this interface must implement this method.
<2> The `default` keyword means that every implementing class will have this method. We name this method `await` but you can name it `findElementWithTimeout` or anything makes sense to you and your team.
<3> You provide an additional method to find methods using wait.
<4> The class implements this interface can still extend other abstract class
<5> We use `Supplier<By>` as parameter so it take the enums as parameter.
<6> The diamond operator is for type inference operation

[sidebar]
.Type inference
****
Type inference refers to the implicitly deduction of the class type of an expression in a programming language. The Diamond Operator `<>` reduces some of Java's verbosity surrounding generics by having the compiler infer parameter types for constructors of generic classes.

In the following snippet, `this` is an `ExplicitWait`,

[source,java]
----
new FluentWait<>(this)
----

So it can be inferred that the what inside the `<>` operation is an `ExplicitWait`

[source,java]
----
new FluentWait<ExplicitWait>(this)
----

This works only after Java 7.
****

[sidebar]
.Why we call the method in `ExplicitWait` `await`
****
We introduced a technique in Chapter 2 to use chained locators, so we can chain the search methods. If we called this method `findElementWithWait`, it would be too long when we chained multiple method together. For example, this code snippet uses `findElementWithWait`, we need to break it into two lines, otherwise it will run over.

[source,java]
----
browser.findElementWithWait(CALENDAR)
       .findElementWithWait(PREV_MONTH_BUTTON)
----

While the one using `await` can have two chained methods on one line,

[source,java]
----
browser.await(CALENDAR).await(PREV_MONTH_BUTTON)
----

You can see `await` is shorter and cleaner. Also `await` is meaningful to identify a wait. `FluentWait` just has two `until` methods, one takes a `Predicate` as parameter and another takes a `Function`. But in `ExplicitWait` interface, we use `await` to make it distinguishable from the `until` methods in `FluentWait`.
****

Both `Browser` and `Element` already have the `findElement` method. To get the new `await` method, they can implement `ExplicitWait` interface. Now let us look at these two classes, after the change, they both have the `await` method now.

`Browser` class implements `ExplicitWait` so it has `await` method,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v1/Browser.java#L6-L12[Browser.java]
----
public class Browser extends DelegatingWebDriver
    implements ExplicitWait {   <2>

    public Browser(WebDriver driver) {   <1>
        super(driver);
    }
}
----
<1> You wrap up an existing driver.
<2> Since `Browser` implements `ExplicitWait`, it inherently has the `await` method

`Element` class implements `ExplicitWait` so it also inherits the `await` methods,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v1/Element.java#L6-25[Element.java]
----
public class Element implements ExplicitWait {  <2>

    private final WebElement webElement;

    public Element(WebElement webElement) {  <1>
        this.webElement = webElement;
    }

    @Override
    public WebElement findElement(Supplier<By> by) {
        return webElement.findElement(by);
    }
}
----
<1> Wrap the existing WebElement.
<2> It implements `ExplicitWait` so it has `await` method

Now we can call the `await` method from both `Browser` and `Element`.

We collect the locators into `LinkText` enum.

[source,java]
----
CHOOSE_LOCATION("choose location"),
MEXICO("MEXICO"),
CANCUN("Cancun"),
----

And add `LOCATION` to `Id` locator supplier enum,

[source,java]
----
LOCATION("location"),
----

You can see in the following test, `await` can be called from both `Browser` and `Element`, and this test is much smaller than Listing <<explicit-waits>>, only one quarter of the code, which explains why we want to use framework.

[[explicit-test]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/tests/ExplicitWait_v1_IT.java#L28-L35[ExplicitWait_v1_IT.java]
----
browser.get("/location-chooser.html");
browser.await(CHOOSE_LOCATION).click();                   //<1>
Element tabMenu = new Element(browser.await(LOCATION));  //<2>
tabMenu.await(MEXICO).click();                            //<3>
tabMenu.await(CANCUN).click();
assertEquals("Cancun", browser.await(TOOLS_LOCATION_STRONG)
    .getText());
----
<1> await is available from browser
<2> await is available from element
<3> But since the `await` returns `WebElement` so we need to create a `Element`

Even if you still use pre-Java 8 version, you can still use this technique by using Google Guava library. You can download it by adding the following section to `pom.xml` file,

[source,xml]
.Dependency for Google Guava library
----
<dependency>                           <1>
  <groupId>com.google.guava</groupId>
  <artifactId>guava</artifactId>
  <version>19.0</version>
</dependency>
----
<1> Added this block anywhere inside the <dependencies>...</dependencies> block

[sidebar]
.Guava Library
****
Guava library was a nice library to provide some nice Java 8 features. Java 8 has similar classes and interfaces in `java.util.function` package. You don't need to add the dependency block when you use Selenium WebDriver. WebDriver has a dependency on Guava library so the project using Selenium automatically has the dependency.
****

And alternatively, how can we implement it in project using pre-Java 8 version.

==== What we do in pre-Java 8

If you don't use Java 8, you need to define an empty `await` method in `ExplicitWait` interface and provide the implementation in each class which implements `ExplicitWait`,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v1_0_prejava8/ExplicitWait.java#L6-L9[ExplicitWait.java]
----
public interface ExplicitWait {
    WebElement findElement(Supplier<By> by);
    WebElement await(Supplier<By> by);  <1>
}
----
<1> An empty method

Then we implement `public WebElement await(Supplier<By> by)` in both `Browser` and `Element` class,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v1_0_prejava8/Browser.java#L13-L32[Browser.java]
----
    public WebElement await(final Supplier<By> by) {  //<1>
        return new FluentWait<>((ExplicitWait) this)   <3>
            .withTimeout(10, TimeUnit.SECONDS)
            .pollingEvery(100, TimeUnit.MILLISECONDS)
            .ignoring(NoSuchElementException.class)
            .until(new Function<ExplicitWait, WebElement>() {   <4>
                @Override
                public WebElement apply(ExplicitWait browser) {
                    return browser.findElement(by);
                }
            }); //<2>
    }
----
<1> Implement the method from `ExplicitWait`
<2> Need to create anonymous inner class of `Function<Browser, WebElement>` if you don't use Java 8
<3> This is called type inference using Diamond Operator and the result is a `Browser`
<4> Since the `FluentWait` is with `Browser` type, so the parameter for `until` needs to be a `Function<Browser, WebElement>` type

You can see another advantage of using Java 8 is not to repeat the implementation if they can use the default one in the interface, even they are not exactly same. You can still introduce a super class to remove this duplicated methods.

Regardless whether you use Java 8 or not, the test is same as Listing <<explicit-test>>.



The examples give us a clear idea of some of the benefits of wrapping up common WebDriver classes. But you need to invoke the constructor of the `Element` every time you use the `await` method.

[source,java]
----
Element tabMenu = new Element(browser.await(Id.LOCATION));
----

The reason is when `await` method returns a `WebElement` interface, which is an original interface from WebDriver library, you lose the wrapping you have done around it. To overcome this shortcoming, `await` method need to return an `Element` instead, that way, you can continue using the wrapped `WebElement` and you can take advantage of the functionalities attached to `Element`. It means the framework code in Listing <<less-optimal>> is not optimal, we need to improve it to have it returning an `Element` rather than a `WebElement`.

So we are making the change, the new code is shown in the following listing, `WebElement` is replaced by `Element`,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v1_5/ExplicitWait.java#L11-22[ExplicitWait.java]
----
public interface ExplicitWait {

    Element findElement(Supplier<By> by); // <1>

    default Element await(Supplier<By> by) {...} <2>
}
----
<1> Return `Element` instead of `WebElement` now
<2> Return `Element` instead of `WebElement` now

So we can assign the result of `await` to an `Element` without calling `new Element(...)` and it saves a lot of boiler plate code.

[source,java]
----
Element tabMenu = browser.await(Id.LOCATION);
----

Here is the sequence diagram of the `await` method.

image::await-seq.png[title=Sequence diagram `await` method]

We can attach more responsibility to this `Browser` and `Element` classes to make them more versatile.

=== Using an `Optional` class To Check For Element Presence

There is situation that some element may appear or may not. To handle this situation gracefully, we are going to provide another method to use an `Optional` class as an wrapper for the element we are trying to find as the return type. When nothing found, the `isPresent()` method of that `Optional` object returns `false`, when it is found, its `get()` method will return the element. This technique works better with Java 8 installation, since it is a built interface from the JDK.

Then you can use the `Optional` class from Guava library. It provides same functionality as the one from Java 8. Here is the JavaDoc for Guava *`Optional` class* footnote:[http://docs.guava-libraries.googlecode.com/git/javadoc/com/google/common/base/Optional.html]



Code for checking for the presence of an element must catch `NoSuchElementException`. This adds several lines of code to each use.



Provide an `optionalElement` method to find optional elements. Again, you want to create a method that you could add to both `Browser` and to `Element`. This can be done as per listing <<optional-element>> below. If you haven't use Java 8 yet, the default method is not available in earlier version of Java. You need to have an empty method and repeat the implementation in each of the class which implements this interface

[[optional-element]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v2/SearchScope.java#L8-L19[SearchScope.java]
----
public interface SearchScope {

    Element findElement(Supplier<By> by);

    default Optional<Element> optionalElement(Supplier<By> by) {  <1>
        try {
            return Optional.of(findElement(by));
        } catch (NoSuchElementException ignored) {
            return Optional.empty();     //<2>
        }
    }
}
----
<1> Only available in Java 8 or via Guava library
<2> This is from `java.util.Optional`, it is called `absent()` in Guava `Optional`

You can then update `Element` and `Browser` to implement it, in the same manner you did for `ExplicitWait` previously. Since there is a `findElement` method in `SearchScope` interface, we can have `ExplicitWait` extending `SearchScope` and remove the `findElement` method from `ExplicitWait` interface.

But in older version of Java, `SearchScope` is like this,

[[optional-element-pre-java8]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v1_5_prejava8/SearchScope.java#L3-L11[SearchScope.java]
----
import org.openqa.selenium.By;
import com.google.common.base.Optional;  <2>

public interface SearchScope {
    Element findElement(Supplier<By> by);
    Optional<Element> optionalElement(Supplier<By> by); <1>
}
----
<1> Pre-Java 8 interface
<2> Import an interface from Google Guava library

And the classes implementing `SearchScope` interface would have to repeat the same implementation, just as illustrated by the following code snippets,

[[element]]
[source,java]
.Pre-Java 8 implementation
----
public class Element implements SearchScope {
    ...
    public Optional<Element> optionalElement(Supplier<By> by) {  <1>
        try {
            return Optional.of(findElement(by));
        } catch (NoSuchElementException ignored) {
            return Optional.absent();   //<2>
        }
    }
}
----
<1> `Browser` class has exactly the same implementation
<2> The `empty()` method of `java.util.Optional` is call `absent()` in Guava `Optional` class.

The same `public Optional<Element> optionalElement(By by)` is repeated in Browser,

[source,java]
.Pre-Java 8 implementation
----
public class Browser implements SearchScope {
    ...
    public Optional<Element> optionalElement(Supplier<By> by) {
        ...       <1>
    }
}
----
<1> Exactly same as listing <<element>>

Then you can call the `isPresent` method to check whether you has found something using `Supplier<By>`. If `isPresent` is true, it means you you have found an element, otherwise not.

Also you can see `click` method is used multiple times in Listing <<explicit-test>>, so you can add these method to `ExplicitWait` for the time being. We are going to show another technique next.

=== Adding helper methods for some frequently used method call.

In Listing <<explicit-test>>, we can see there are three occurrences of `await` method call followed by calling `click`. These two methods are frequently used together in web automation code. Also you need to call `getText` after calling `await`.



Often, we need to find an element and click it using `await` method call followed by calling `click`. Also we need to find an element and read its text using `getText` after calling `untiFound`. And we also check whether an element can be found by using a `By` locater. These chained methods calls are very frequent and they are repeated everywhere.



We can achieve this by adding helper methods to give a single method call so you no longer expose a chained method calls in the code,

[source,java]
----
default void click(Supplier<By> by) {
    await(by).click();
}

default String getText(Supplier<By> by) {
    return await(by).getText();
}
----

And add this method into `SearchScope`, it can be used to check whether an element can be found using the giving locator enum, same as by calling `optionalElement(by).isPresent()` in a method chain.

[source,java]
----
default boolean isPresent(Supplier<By> by) {
    return optionalElement(by).isPresent();
}
----

Then we can replace the chained method calls in Listing <<explicit-test>> and add another line to check whether the link for `Cancun` is still there. The test asserts it shouldn't be there, since it should close after being clicked.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/tests/ExplicitWait_v2_IT.java#L29-L37[ExplicitWait_v2_TT.java]
----
browser.click(CHOOSE_LOCATION);
Element tabMenu = browser.await(LOCATION);
tabMenu.click(MEXICO);
tabMenu.click(CANCUN);
assertEquals("Cancun", browser.getText(TOOLS_LOCATION_STRONG));
assertFalse(tabMenu.isPresent(CANCUN));       //<1>
----
<1> Here you can check that "Cancun" is not present.

You can see the `isPresent`, `click` and `getText` methods makes the code cleaner. This block of code provides the same functionality of Listing <<explicit-waits1>> and Listing <<explicit-waits2>> together.

`Element.getAttribute("value")` is also used frequently, we can add following method to `DelegatingWebElement`,

[source,java]
----
    public String getValue() {
        return delegate.getAttribute("value");
    }
----

Then we can just call `Element.getValue()`.



The reason we add these helper methods into `ExplicitWait` class is because both `Browser` and `Element` implements `ExplicitWait` interface, the helper methods in `ExplicitWait` are available for them. And we make code simpler and pleasant to read.

There are other examples of using framework to add functionality. By introducing a `Browser` class, you can attach other useful methods to it simplifies the calling code, as illustrated by the following table:

.Compare code with and without using framework
[width="80%",cols="3,^2,^2,10",options="header"]
|=======================================================================
|
|Without framework
|With framework
|Benefit

|Clicking OK on a message alert
|`driver.switchTo() .alert() .accept();`
| `browser .acceptAlert();`
| Hide the method chain

|Drag and Drop
|`new Actions(driver) .dragAndDrop( findElement(from), findElement(to)) .perform();`
| `browser .dragAndDrop (from, to);`
| More concise code
|=======================================================================

So instead of using following chained method calls,

[source,java]
----
driver.switchTo().alert().accept();
----

You can just use one method invocation, which is much shorter and concise by hiding the method chain.

[source,java]
----
browser.acceptAlert();
----

Also, you don't need to have this lengthy method with object creation and method invocation,

[source,java]
----
new Actions(driver).dragAndDrop(findElement(from), findElement(to)).perform();
----

You can just use a single method to achieve the same functionality,

[source,java]
----
 browser.dragAndDrop(from, to);
----

That's the beauty of using frameworks.

== Making framework backwards compatible with existing codebase

Before we develop this framework, there may already exist some tests with the method taking `WebDriver` and `WebElement` interfaces as parameter, we would like to use the `Browser` and `Element` interfaces as the parameter to those code, so the investment we made in the past can be recycled to take advantage of this new framework. You may wonder why we need to do this, let us take a look of the following test.

[source,java]
----
driver.switchTo().frame(editorFrame);
----

We are trying to switch to the iframe but it will fail with `IllegalArgumentException`. When you run the test, it prints the following stack trace,

[source,java]
----
java.lang.IllegalArgumentException: Argument is of an illegal type:
swb.ch13framework.v2.Element
	at WebElementToJsonConverter.apply(WebElementToJsonConverter.java:81)
	at RemoteTargetLocator.frame(RemoteWebDriver.java:1003)
	at WyswygInputFailureIT.failToSwitchToIframe(WyswygInputFailureIT.java:35)
----

We follow the stack trace to WebDriver source code and find the exception is thrown by the `apply` method of `WebElementToJsonConverter` class.
[source,java]
.link:https://github.com/SeleniumHQ/selenium/blob/master/java/client/src/org/openqa/selenium/remote/internal/WebElementToJsonConverter.java#L41-L83[WebElementToJsonConverter.java]
----
while (arg instanceof WrapsElement) {    <1>
    arg = ((WrapsElement) arg).getWrappedElement();  <3>
}
...
throw new IllegalArgumentException("Argument is of an illegal type: " + <2>
  arg.getClass().getName());
----
<1> This is to extract the inner most `WrapsElement` if it is wrapped many times.
<2> The exception is thrown here
<3> From this logic we can know, as long as we have `DelegatingWebDriver` implementing `WrapsElement`, it will use what is wrapped inside.

From its logic, we know it expects that our class that wraps `WebElement` needs to implement `WrapsElement` interface. We are going to do this to `WebDriver` and `WebElement` interfaces to make them backwards compatible.

=== Making `Browser` Backwards Compatible By Implementing `WebDriver`

First let us make `Browser` class backwards compatible so it can be used in the code where expecting a `WebDriver` interface as parameter.



You have a `Browser` class which can use for new tests, and you'd like to use it in existing tests, so you only have to manage one driver.



To do this you can add interface `WrapsDriver` to `DelegatingWebDriver` class as per listing <<delegating-webdriver>> below. You can then sub-class it to override specific methods.

[[delegating-webdriver]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v3/DelegatingWebDriver.java#L12-L122[DelegatingWebDriver.java]
----
public class DelegatingWebDriver
    implements WebDriver, JavascriptExecutor, TakesScreenshot,
    HasInputDevices, HasCapabilities, WrapsDriver {  <4>
    private final WebDriver delegate; // <1>

    public DelegatingWebDriver(WebDriver delegate) {
        this.delegate = delegate;
    }
    ... // <2>
    @Override
    public WebDriver getWrappedDriver() {    <3>
       return ((WrapsDriver)driver).getWrappedDriver();
    }
}
----
<1> Store the delegate.
<2> The remaining methods all delegate their calls to `WebDriver delegate`.
<3> This method is from interface `WrapsDriver`
<4> Add `WrapsDriver` interface as one of the interfaces

After this change, this class is safe to be used for framework code and we made it backwards compatible with existing framework. With this class, you can sub-class it, and only override the methods you need to change the behavior of.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v3/Browser.java#L5-L116[Browser.java]
----
public class Browser extends DelegatingWebDriver {

    public Browser(WebDriver driver) {
        super(driver);
    } // <1>
}
----
<1> The constructor of the `Browser` class



By applying Object Oriented principle, we made `Browser` backwards compatible with old tests. Let us go back to chapter 5, Making maintainable tests using the Page Object pattern, and take another look of Listing 5.8 link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch05pageobjects/d/SearchPage.java[d/SearchPage.java]. In the listing, `SearchPage` class takes a `WebDriver` interface as the constructor parameter, now we are going to pass it a `Browser` object. Will it work? Let us see.

We create this new test `SearchPageV2IT` and run it with a `BrowserRunner` runner class so it will inject a `Browser` into the test, we then create a `SearchPage` using the `browser` variable,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/tests/SearchPage_v2_IT.java#L12-L27[SearchPage_v2_IT.java]
----
import swb.ch05pageobjects.d.SearchPage;  <1>

@RunWith(BrowserRunner.class)
public class SearchPage_v2_IT {
    @Inject
    private Browser browser;

    @Test
    public void search() throws Exception {
        SearchPage searchForm = new SearchPage(browser);  <2>
        searchForm.searchFor("funny cats");
    }
}
----
<1> This `swb.ch05pageobjects.d.SearchPage` class is for old tests and it expects `WebDriver` interface as the constructor parameter
<2> We pass a `Browser` class as parameter now and it still works

The test passes, it works! By making `Browser` implementing `WebDriver`, we make it backwards compatible with many existing Page Object we had written in the past.

Now let us make `Element` class backwards compatible so it can be used in the code where expecting a `WebElement` interface as parameter.

=== Making `Element` Backwards Compatible By Implementing `WrapsElement` interface

It is the same case with `Element` class too.



You have an `Element` class which can use for new tests, and you'd like to use it in existing tests, so you only have to manage one element.



Again, use the delegate pattern to delegate the code to another class. To do this you can create a new class `DelegatingWebElement` as per listing <<delegating-webelement>> below and have it implementing `WrapsElement` interface. You can then sub-class it to override specific methods.

[[delegating-webelement]]
[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v3/DelegatingWebElement.java#L8-L105[DelegatingWebElement.java]
----
public class DelegatingWebElement implements WebElement, WrapsElement {   <3>
    private final WebElement delegate;

    public DelegatingWebElement(WebElement delegate) {
        this.delegate = delegate;   <1>
    }
    ... // <2>
    @Override
    public WebElement getWrappedElement() {
        return delegate;                      <4>
   }
}
----
<1> Store the delegate.
<2> The remaining methods all delegate their calls.
<3> Add `WrapsElement` as one of the interfaces
<4> Return the wrapped `WebElement`

With this class, you can sub-class it, and only override the methods you need to change the behavior of.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v3/Element.java#L5-L16[Element.java]
----
public class Element extends DelegatingWebElement {

    public Element(WebElement delegate) {   <1>
        super(delegate);
    }
}
----
<1> The constructor of the `Element` class



Creating a delegate allows us to override specific methods, and yet keep our code readable. In this example you have use it to extend `Element` to allow it to be used as a drop-in and backwards compatible replacement for `WebElement` in existing code.

Let is use `LoginForm` class in Listing 5.2 link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch05pageobjects/LoginForm.java[LoginForm.java] from Chapter 5, and create new test using `Browser` and `Element` and this old `LoginForm`,

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/tests/LoginForm_v2_IT.java#L26-L35[LoginForm_v2_IT.java]
----
@Test
public void checkLoginForm() throws Exception {
    Element login = driver.await(LOGIN);  <2>

    LoginForm loginForm = new LoginForm(login);  <1>
    loginForm.loginAs("foo@bar.com", "secret");

    new WebDriverWait(driver, 1)    <3>
        .until(ExpectedConditions.titleIs("You Are Logged In"));
}
----
<1> It uses the `swb.ch05pageobjects.LoginForm` class created in Chapter 5 that takes `WebElement` as constructor parameter
<2> Now we pass an `Element` object to its constructor
<3> `WebDriverWait` expects `WebDriver` but we pass in `Browser`

And it still works so we achieved our goal of making them compatible with the old tests.

=== Introduce base class to reduce duplicated code

Let us look at these two methods,

[[repeated-method]]
[source,java]
.Methods in both link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v3/DelegatingWebDriver.java#L49-L57[DelegatingWebDriver.java] and link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v3/DelegatingWebElement.java#L15-L23[DelegatingWebElement.java]
----
@Override
public List<WebElement> findElements(Supplier<By> by) {
    return delegate.findElements(by);
}

@Override
public Element findElement(Supplier<By> by) {  //<4>
    return new Element(delegate.findElement(by));
}
----

You can see from Listing <<delegating-webdriver>> and <<delegating-webelement>>, they belong to both `DelegatingWebDriver` and `DelegatingWebElement`.

And since these two methods are from interface `SearchContext`, we can implement that interface to introduce `DelegatingSearchContext` as super class for `DelegatingWebDriver` and `DelegatingWebElement` and take advantage of Java Generics to have this class take a type, which can be any subtype of `SearchContext`, either a `WebDriver` or a `WebElement`, so in the subclass of `DelegatingWebDriver`, where we use `WebDriver` as the generic type parameter, `T` in `protect final T delegate` is a `WebDriver` class. But in `DelegatingWebElement`, it is `WebElement`. If you just declared it as `SearchContext`, you would need to cast it to `WebDriver` in `DelegatingWebElement` and `WebElement` in `DelegatingWebElement` before you could call the methods of each interface.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v4/DelegatingSearchContext.java#L10-L33[DelegatingSearchContext.java]
----
public class DelegatingSearchContext<T extends SearchContext>  //<1>
    implements SearchContext, ExplicitWait {
    protected final T delegate; // <2>

    public DelegatingSearchContext(T delegate) {
        this.delegate = delegate;
    }
    ... <3>
}
----
<1> The type parameter of this class is any subtype of `SearchContext`
<2> Make this variable protected so it is accessible from its subclass
<3> We implement `findElements`, `findElement` methods and remove them from both `DelegatingWebDriver` and `DelegatingWebElement`

Then we can have `DelegatingWebDriver` extending `DelegatingSearchContext` with type parameter `WebDriver`, delete the variable `WebDriver driver` from it, and delete those two methods in Listing <<repeated-method>> from `DelegatingWebDriver`.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v4/DelegatingWebDriver.java#L11-L108[DelegatingWebDriver.java]
----
public class DelegatingWebDriver
    extends DelegatingSearchContext<WebDriver> <1>
    implements WebDriver, JavascriptExecutor, TakesScreenshot,
    HasInputDevices, HasCapabilities, WrapsDriver {

    public DelegatingWebDriver(WebDriver delegate) {
        super(delegate);     //<2>
    }
    ... <3>
}
----
<1> The type for DelegatingWebDriver is WebDriver
<2> Call constructor of super class and pass the instance of WebDriver
<3> The rest of the methods also remain unchanged

Here is the class diagram of `Browser` class and its ancestors from WebDriver.

image::Browser.png[title=Class diagram of the Browser and its ancestors]

And have `DelegatingWebElement` extending `DelegatingSearchContext` with type parameter `WebElement`, delete the variable `WebElement element` from it, and delete those two methods in Listing <<repeated-method>> from `DelegatingWebElement`.

[source,java]
.link:https://github.com/selenium-webdriver-book/source/blob/master/src/test/java/swb/ch13framework/v4/DelegatingWebElement.java#L8-L99[DelegatingWebElement.java]
----
public class DelegatingWebElement
    extends DelegatingSearchContext<WebElement> //<1>
    implements WebElement {

    public DelegatingWebElement(WebElement delegate) {
        super(delegate);  //<2>
    }
    ... <3>
}
----
<1> The type for DelegatingWebElement is WebElement
<2> Call constructor of super class and pass the instance of `WebElement`
<3> The rest of the methods also remain unchanged

And here is the class diagram of `Element` class and its ancestors from WebDriver.

image::Element.png[title=Class diagram of the Element and its ancestors]

Now the framework evolved to a better state, comparing to the beginning of this chapter. It will continue evolve in the coming chapters.

== Summary

* Code that talks directly to `WebDriver` can be reduced in size
* Wrapping `WebDriver` allows you alter the behavior of existing method
* Wrapping allows you extend `WebDriver` with new methods
* You can make these change, while at the same time keeping the code backwards compatible

In the next chapter you will learn how to encapsulate some common operations related to form elements and how to organize the elements into logical groups to simplify the page object.
